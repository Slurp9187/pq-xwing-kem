// src/combiner.rs
use super::SharedSecret;
use sha3::{Digest, Sha3_256};

pub(crate) const X_WING_LABEL: &[u8] = br"\.//^\";

/// Combines the outputs from ML-KEM and X25519 into a single shared secret using SHA3-256.
/// This follows the X-Wing KEM specification to derive a hybrid post-quantum/classical shared secret.
/// Inputs: ML-KEM shared secret (ss_m), X25519 DH shared secret (ss_x), X25519 ephemeral public key (ct_x), and X25519 static public key (pk_x).
/// The domain separator label is appended to ensure uniqueness and prevent cross-protocol attacks.
pub fn combiner(
    // ss_m: Shared secret from ML-KEM (post-quantum KEM). This is the output of ML-KEM decapsulation (for recipient) or encapsulation (for sender), a 32-byte symmetric key derived from lattice-based cryptography. It provides the main post-quantum security for the hybrid scheme.
    ss_m: &[u8; 32],
    // ss_x: Shared secret from X25519 Diffie-Hellman key exchange. This is the result of the ephemeral-static DH computation (ephemeral_key * static_public_key), a 32-byte value that adds classical ECDH security to mitigate ML-KEM weaknesses.
    ss_x: &[u8; 32],
    // ct_x: X25519 ciphertext/public key. This is the ephemeral public key generated by the sender during encapsulation (a 32-byte Curve25519 point). The recipient uses this to compute ss_x via Diffie-Hellman.
    ct_x: &[u8; 32],
    // pk_x: Recipient's static X25519 public key. This is the long-term public key of the recipient (a 32-byte Curve25519 point). It's used to compute ss_x and ensures the DH exchange is bound to the correct recipient.
    pk_x: &[u8; 32],
) -> SharedSecret {
    Sha3_256::new()
        .chain_update(ss_m)
        .chain_update(ss_x)
        .chain_update(ct_x)
        .chain_update(pk_x)
        .chain_update(X_WING_LABEL)
        .finalize()
        .into()
}
