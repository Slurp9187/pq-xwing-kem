// ============================================================================
// pq-xwing-kem â€“ All integration tests
// Generated by: package_it.py
// Generated at: 2025-12-27 22:54:40.578
// ============================================================================

// ============================================================================
// TABLE OF CONTENTS
// ============================================================================
// 001. tests/combiner_tests.rs
// 002. tests/xwing1024_tests.rs
// 003. tests/xwing768_tests.rs
// ============================================================================




================================================================================
// SECTION 001: tests/combiner_tests.rs
// Created:  2025-12-23 19:36:11.339
// Modified: 2025-12-23 19:36:18.541
================================================================================
//! Unit tests for combiner.

use pq_xwing_kem::combiner::combiner;
use pq_xwing_kem::consts::SHARED_SECRET_SIZE;
use sha3::{Digest, Sha3_256};

#[test]
fn test_combiner_consistency() {
    let ss_m = [1u8; 32];
    let ss_x = [2u8; 32];
    let ct_x = [3u8; 32];
    let pk_x = [4u8; 32];

    let result1 = combiner(&ss_m, &ss_x, &ct_x, &pk_x);
    let result2 = combiner(&ss_m, &ss_x, &ct_x, &pk_x);

    assert_eq!(result1, result2);
    assert_eq!(result1.len(), SHARED_SECRET_SIZE);
}

#[test]
fn test_combiner_different_inputs() {
    let ss_m = [1u8; 32];
    let ss_x = [2u8; 32];
    let ct_x = [3u8; 32];
    let pk_x = [4u8; 32];

    let result1 = combiner(&ss_m, &ss_x, &ct_x, &pk_x);
    let result2 = combiner(&ss_x, &ss_m, &pk_x, &ct_x); // swapped

    assert_ne!(result1, result2);
}

#[test]
fn test_combiner_includes_label() {
    // The label should ensure output differs from plain SHA3-256 of inputs
    let ss_m = [0u8; 32];
    let ss_x = [0u8; 32];
    let ct_x = [0u8; 32];
    let pk_x = [0u8; 32];

    let plain_hash = Sha3_256::new()
        .chain_update(ss_m)
        .chain_update(ss_x)
        .chain_update(ct_x)
        .chain_update(pk_x)
        .finalize();
    let combined = combiner(&ss_m, &ss_x, &ct_x, &pk_x);

    assert_ne!(plain_hash.as_slice(), combined.as_slice());
}

#[test]
fn test_combiner_all_zero_inputs() {
    let ss_m = [0u8; 32];
    let ss_x = [0u8; 32];
    let ct_x = [0u8; 32];
    let pk_x = [0u8; 32];
    let result = combiner(&ss_m, &ss_x, &ct_x, &pk_x);
    // Should still produce a non-zero hash due to the label
    assert!(!result.iter().all(|&b| b == 0));
    assert_eq!(result.len(), SHARED_SECRET_SIZE);
}



================================================================================
// SECTION 002: tests/xwing1024_tests.rs
// Created:  2025-12-23 19:36:38.177
// Modified: 2025-12-27 22:52:45.031
================================================================================
//! Unit tests for xwing1024.

use pq_xwing_kem::xwing1024::{
    generate_keypair, Ciphertext, EncapsulationKey, XWING1024_CIPHERTEXT_SIZE,
    XWING1024_ENCAPSULATION_KEY_SIZE,
};
use pq_xwing_kem::Error;
use rand_core::OsRng;

#[test]
fn test_generate_keypair() {
    let mut rng = OsRng;
    let (_sk, pk) = generate_keypair(&mut rng);

    assert_eq!(pk.to_bytes().len(), XWING1024_ENCAPSULATION_KEY_SIZE);
}

#[test]
fn test_encapsulation_decapsulation_roundtrip() {
    let mut rng = OsRng;
    let (sk, pk) = generate_keypair(&mut rng);

    let (ct, ss_encap) = pk.encapsulate(&mut rng).unwrap();
    let ss_decap = sk.decapsulate(&ct).unwrap();

    assert_eq!(ss_encap, ss_decap);
    assert_eq!(ct.to_bytes().len(), XWING1024_CIPHERTEXT_SIZE);
}

#[test]
fn test_encapsulation_key_serialization() {
    let mut rng = OsRng;
    let (_sk, pk) = generate_keypair(&mut rng);

    let pk_bytes = pk.to_bytes();
    let pk_restored = EncapsulationKey::try_from(&pk_bytes).unwrap();

    assert_eq!(pk, pk_restored);
}

#[test]
fn test_ciphertext_serialization() {
    let mut rng = OsRng;
    let (_sk, pk) = generate_keypair(&mut rng);

    let (ct, _) = pk.encapsulate(&mut rng).unwrap();
    let ct_bytes = ct.to_bytes();
    let ct_restored = Ciphertext::try_from(&ct_bytes).unwrap();

    assert_eq!(ct, ct_restored);
}

#[test]
fn test_different_keys_produce_different_secrets() {
    let mut rng = OsRng;
    let (_sk1, pk1) = generate_keypair(&mut rng);
    let (_sk2, pk2) = generate_keypair(&mut rng);

    let (ct1, ss1) = pk1.encapsulate(&mut rng).unwrap();
    let (ct2, ss2) = pk2.encapsulate(&mut rng).unwrap();

    assert_ne!(ss1, ss2);
    assert_ne!(ct1, ct2);
}

#[test]
fn test_wrong_key_decapsulate_fails() {
    let mut rng = OsRng;
    let (_sk1, pk1) = generate_keypair(&mut rng);
    let (sk2, _pk2) = generate_keypair(&mut rng);

    let (ct, ss_encap) = pk1.encapsulate(&mut rng).unwrap();
    let ss_decap = sk2.decapsulate(&ct).unwrap();

    // Since it's hybrid, and ML-KEM decapsulates to random if wrong key,
    // but X25519 will give different ss_x, so overall different secret.
    assert_ne!(ss_encap, ss_decap);
}

#[test]
fn test_encapsulation_non_zero_ciphertext() {
    let mut rng = OsRng;
    let (_, pk) = generate_keypair(&mut rng);
    let (ct, _) = pk.encapsulate(&mut rng).unwrap();
    // Ensure CT is not all zeros
    assert!(!ct.to_bytes().iter().all(|&b| b == 0));
}

#[test]
fn test_decapsulation_modified_ciphertext_fails() {
    let mut rng = OsRng;
    let (sk, pk) = generate_keypair(&mut rng);
    let (ct, ss_encap) = pk.encapsulate(&mut rng).unwrap();
    // Modify the CT
    let mut modified_bytes = ct.to_bytes();
    modified_bytes[0] ^= 1; // Flip a bit
    let modified_ct = Ciphertext::try_from(&modified_bytes).unwrap();
    let ss_decap = sk.decapsulate(&modified_ct).unwrap();
    // Should produce different secret
    assert_ne!(ss_encap, ss_decap);
}

#[test]
fn test_ciphertext_size() {
    let mut rng = OsRng;
    let (_, pk) = generate_keypair(&mut rng);
    let (ct, _) = pk.encapsulate(&mut rng).unwrap();
    assert_eq!(ct.to_bytes().len(), XWING1024_CIPHERTEXT_SIZE);
}

#[test]
fn test_invalid_x25519_public_key_validation() {
    // Test that all-zero X25519 public key is rejected
    let mut invalid_pk_bytes = [0u8; XWING1024_ENCAPSULATION_KEY_SIZE];
    // First 1568 bytes are ML-KEM key (leave as zeros for this test)
    // Last 32 bytes are X25519 public key - set to all zeros (invalid)
    invalid_pk_bytes[XWING1024_ENCAPSULATION_KEY_SIZE - 32..].fill(0);

    let result = EncapsulationKey::try_from(&invalid_pk_bytes);
    assert!(result.is_err());
    assert!(matches!(result.unwrap_err(), Error::InvalidX25519PublicKey));
}



================================================================================
// SECTION 003: tests/xwing768_tests.rs
// Created:  2025-12-23 19:36:32.235
// Modified: 2025-12-27 22:52:45.032
================================================================================
// pq-xwing-kem\tests\xwing768_tests.rs
//! Unit tests for xwing768.

use pq_xwing_kem::xwing768::{
    generate_keypair, Ciphertext, EncapsulationKey, XWING768_CIPHERTEXT_SIZE,
    XWING768_ENCAPSULATION_KEY_SIZE,
};
use pq_xwing_kem::Error;
use rand_core::OsRng;

#[test]
fn test_generate_keypair() {
    let mut rng = OsRng;
    let (_sk, pk) = generate_keypair(&mut rng);

    assert_eq!(pk.to_bytes().len(), XWING768_ENCAPSULATION_KEY_SIZE);
}

#[test]
fn test_encapsulation_decapsulation_roundtrip() {
    let mut rng = OsRng;
    let (sk, pk) = generate_keypair(&mut rng);

    let (ct, ss_encap) = pk.encapsulate(&mut rng).unwrap();
    let ss_decap = sk.decapsulate(&ct).unwrap();

    assert_eq!(ss_encap, ss_decap);
    assert_eq!(ct.to_bytes().len(), XWING768_CIPHERTEXT_SIZE);
}

#[test]
fn test_encapsulation_key_serialization() {
    let mut rng = OsRng;
    let (_sk, pk) = generate_keypair(&mut rng);

    let pk_bytes = pk.to_bytes();
    let pk_restored = EncapsulationKey::try_from(&pk_bytes).unwrap();

    assert_eq!(pk, pk_restored);
}

#[test]
fn test_ciphertext_serialization() {
    let mut rng = OsRng;
    let (_sk, pk) = generate_keypair(&mut rng);

    let (ct, _) = pk.encapsulate(&mut rng).unwrap();
    let ct_bytes = ct.to_bytes();
    let ct_restored = Ciphertext::try_from(&ct_bytes).unwrap();

    assert_eq!(ct, ct_restored);
}

#[test]
fn test_different_keys_produce_different_secrets() {
    let mut rng = OsRng;
    let (_sk1, pk1) = generate_keypair(&mut rng);
    let (_sk2, pk2) = generate_keypair(&mut rng);

    let (ct1, ss1) = pk1.encapsulate(&mut rng).unwrap();
    let (ct2, ss2) = pk2.encapsulate(&mut rng).unwrap();

    assert_ne!(ss1, ss2);
    assert_ne!(ct1, ct2);
}

#[test]
fn test_wrong_key_decapsulate_fails() {
    let mut rng = OsRng;
    let (_sk1, pk1) = generate_keypair(&mut rng);
    let (sk2, _pk2) = generate_keypair(&mut rng);

    let (ct, ss_encap) = pk1.encapsulate(&mut rng).unwrap();
    let ss_decap = sk2.decapsulate(&ct).unwrap();

    // Since it's hybrid, and ML-KEM decapsulates to random if wrong key,
    // but X25519 will give different ss_x, so overall different secret.
    assert_ne!(ss_encap, ss_decap);
}

#[test]
fn test_encapsulation_non_zero_ciphertext() {
    let mut rng = OsRng;
    let (_, pk) = generate_keypair(&mut rng);
    let (ct, _) = pk.encapsulate(&mut rng).unwrap();
    // Ensure CT is not all zeros
    assert!(!ct.to_bytes().iter().all(|&b| b == 0));
}

#[test]
fn test_decapsulation_modified_ciphertext_fails() {
    let mut rng = OsRng;
    let (sk, pk) = generate_keypair(&mut rng);
    let (ct, ss_encap) = pk.encapsulate(&mut rng).unwrap();
    // Modify the CT
    let mut modified_bytes = ct.to_bytes();
    modified_bytes[0] ^= 1; // Flip a bit
    let modified_ct = Ciphertext::try_from(&modified_bytes).unwrap();
    let ss_decap = sk.decapsulate(&modified_ct).unwrap();
    // Should produce different secret
    assert_ne!(ss_encap, ss_decap);
}

#[test]
fn test_ciphertext_size() {
    let mut rng = OsRng;
    let (_, pk) = generate_keypair(&mut rng);
    let (ct, _) = pk.encapsulate(&mut rng).unwrap();
    assert_eq!(ct.to_bytes().len(), XWING768_CIPHERTEXT_SIZE);
}

#[test]
fn test_invalid_x25519_public_key_validation() {
    // Test that all-zero X25519 public key is rejected
    let mut invalid_pk_bytes = [0u8; XWING768_ENCAPSULATION_KEY_SIZE];
    // First 1184 bytes are ML-KEM key (leave as zeros for this test)
    // Last 32 bytes are X25519 public key - set to all zeros (invalid)
    invalid_pk_bytes[XWING768_ENCAPSULATION_KEY_SIZE - 32..].fill(0);

    let result = EncapsulationKey::try_from(&invalid_pk_bytes);
    assert!(result.is_err());
    assert!(matches!(result.unwrap_err(), Error::InvalidX25519PublicKey));
}
