// ============================================================================
// pq-xwing-kem – Full library source + Cargo.toml
// Generated by: package_it.py
// Generated at: 2025-12-27 22:39:47.209
// ============================================================================

// ============================================================================
// TABLE OF CONTENTS
// ============================================================================
// 001. Cargo.toml
// 002. README.md
// 003. src/combiner.rs
// 004. src/consts.rs
// 005. src/error.rs
// 006. src/lib.rs
// 007. src/xwing1024.rs
// 008. src/xwing768.rs
// ============================================================================




================================================================================
// SECTION 001: Cargo.toml
// Created:  2025-12-22 04:31:19.685
// Modified: 2025-12-23 20:40:02.192
================================================================================
[package]
name = "pq-xwing-kem"
version = "0.1.0"
edition = "2024"
repository = "https://github.com/Slurp9187/pq-xwing-kem"
description = "Post-quantum hybrid X-Wing Key Encapsulation Mechanism (all ML-KEM variants + X25519)."
license = "MIT OR Apache-2.0"
keywords = ["post-quantum", "cryptography", "hybrid", "ML-KEM", "X25519"]
categories = ["cryptography"]

[dependencies]
libcrux-ml-kem = { git = "https://github.com/cryspen/libcrux", package = "libcrux-ml-kem", branch = "main" }
rand_core = { version = "0.6", features = ["getrandom"] }
sha3 = { version = "0.10", default-features = false }
x25519-dalek = { version = "2.0", default-features = false, features = [
  "zeroize",
  "static_secrets",
] }
zeroize = { version = "1.8", features = ["zeroize_derive"] }
thiserror = "2.0"

[dev-dependencies]



================================================================================
// SECTION 002: README.md
// Created:  2025-12-23 20:37:28.258
// Modified: 2025-12-23 20:24:04.760
================================================================================
# pq-xwing-kem

**⚠️ WARNING: This crate is under active development and is not suitable for production use. It may contain security vulnerabilities. Use at your own risk.**

Post-quantum hybrid X-Wing Key Encapsulation Mechanism (all ML-KEM variants + X25519).

This crate attempts to implement the X-Wing hybrid KEM as described in the [X-Wing: general-purpose hybrid post-quantum KEM](https://datatracker.ietf.org/doc/draft-connolly-cfrg-xwing-kem/).

**Current status (v0.0.1 placeholder)**:  
Active development in progress. Functional proof-of-concept implementation exists, but it is **not yet security-hardened** (constant-time guarantees, full fuzzing, formal verification, or external audit pending).

**Do not use in production yet.**

Planned improvements:
- Full constant-time operations
- Extensive testing and fuzzing
- Benchmarks and documentation
- no-std support

See the repository for ongoing work: https://github.com/Slurp9187/pq-xwing-kem



================================================================================
// SECTION 003: src/combiner.rs
// Created:  2025-12-22 04:32:33.099
// Modified: 2025-12-23 18:16:05.958
================================================================================
// src/combiner.rs
use super::SharedSecret;
use sha3::{Digest, Sha3_256};

pub(crate) const X_WING_LABEL: &[u8] = br"\.//^\";

/// Combines the outputs from ML-KEM and X25519 into a single shared secret using SHA3-256.
/// This follows the X-Wing KEM specification to derive a hybrid post-quantum/classical shared secret.
/// Inputs: ML-KEM shared secret (ss_m), X25519 DH shared secret (ss_x), X25519 ephemeral public key (ct_x), and X25519 static public key (pk_x).
/// The domain separator label is appended to ensure uniqueness and prevent cross-protocol attacks.
pub fn combiner(
    // ss_m: Shared secret from ML-KEM (post-quantum KEM). This is the output of ML-KEM decapsulation (for recipient) or encapsulation (for sender), a 32-byte symmetric key derived from lattice-based cryptography. It provides the main post-quantum security for the hybrid scheme.
    ss_m: &[u8; 32],
    // ss_x: Shared secret from X25519 Diffie-Hellman key exchange. This is the result of the ephemeral-static DH computation (ephemeral_key * static_public_key), a 32-byte value that adds classical ECDH security to mitigate ML-KEM weaknesses.
    ss_x: &[u8; 32],
    // ct_x: X25519 ciphertext/public key. This is the ephemeral public key generated by the sender during encapsulation (a 32-byte Curve25519 point). The recipient uses this to compute ss_x via Diffie-Hellman.
    ct_x: &[u8; 32],
    // pk_x: Recipient's static X25519 public key. This is the long-term public key of the recipient (a 32-byte Curve25519 point). It's used to compute ss_x and ensures the DH exchange is bound to the correct recipient.
    pk_x: &[u8; 32],
) -> SharedSecret {
    Sha3_256::new()
        .chain_update(ss_m)
        .chain_update(ss_x)
        .chain_update(ct_x)
        .chain_update(pk_x)
        .chain_update(X_WING_LABEL)
        .finalize()
        .into()
}



================================================================================
// SECTION 004: src/consts.rs
// Created:  2025-12-22 05:07:26.205
// Modified: 2025-12-22 05:19:41.689
================================================================================
pub const X25519_KEY_SIZE: usize = 32;
pub const MASTER_SEED_SIZE: usize = 32;
pub const SHARED_SECRET_SIZE: usize = 32;



================================================================================
// SECTION 005: src/error.rs
// Created:  2025-12-22 05:07:45.680
// Modified: 2025-12-23 18:16:46.107
================================================================================
// src/error.rs

//! Error types for xwing-kem operations.

use thiserror::Error;

/// Errors that can occur during xwing-kem operations.
#[derive(Error, Debug, Clone)]
pub enum Error {
    /// The encapsulation key has an invalid length.
    #[error("Invalid encapsulation key length")]
    InvalidEncapsulationKeyLength,

    /// The ciphertext has an invalid length.
    #[error("Invalid ciphertext length")]
    InvalidCiphertextLength,

    /// The decapsulation key has an invalid length.
    #[error("Invalid decapsulation key length")]
    InvalidDecapsulationKeyLength,

    /// Failed to perform ML-KEM encapsulation.
    #[error("ML-KEM encapsulation failed")]
    MlkemEncapsulateError,

    /// Failed to perform ML-KEM decapsulation.
    #[error("ML-KEM decapsulation failed")]
    MlkemDecapsulateError,

    /// Failed to compute X25519 Diffie-Hellman shared secret.
    #[error("X25519 Diffie-Hellman failed")]
    X25519DhError,
}

/// Type alias for results in xwing-kem.
pub type Result<T> = core::result::Result<T, Error>;



================================================================================
// SECTION 006: src/lib.rs
// Created:  2025-12-22 04:31:19.694
// Modified: 2025-12-27 06:29:43.907
================================================================================
// src/lib.rs

//! # xwing
//!
//! X-Wing hybrid post-quantum KEM (ML-KEM-512/768/1024 + X25519)
//! using libcrux and x25519-dalek.
//!
//! Implements draft-connolly-cfrg-xwing-kem-09 specification.
//!
//! Currently provides:
//! - `xwing512`: ML-KEM-512 + X25519 variant
//! - `xwing768`: ML-KEM-768 + X25519 variant
//! - `xwing1024`: ML-KEM-1024 + X25519 variant

// #![no_std]
// #![deny(missing_docs)]
// #![deny(unsafe_code)]

extern crate alloc;

pub mod combiner;
pub mod consts;
pub mod error;
pub mod xwing1024;
pub mod xwing768;

pub(crate) use combiner::combiner;

pub const XWING_DRAFT_VERSION: &str = "09";

pub use consts::{MASTER_SEED_SIZE, SHARED_SECRET_SIZE};
pub use error::{Error, Result};

/// The shared secret produced by X-Wing KEM encapsulation or decapsulation.
///
/// This is a 32-byte array representing the hybrid post-quantum/classical symmetric key
/// derived from ML-KEM and X25519 components. It ensures type safety for the final output
/// of the scheme's cryptographic operations.
pub type SharedSecret = [u8; SHARED_SECRET_SIZE];



================================================================================
// SECTION 007: src/xwing1024.rs
// Created:  2025-12-22 04:32:33.099
// Modified: 2025-12-27 06:29:43.907
================================================================================
// src/xwing_kem_1024.rs

use crate::combiner;
use crate::consts::{MASTER_SEED_SIZE, X25519_KEY_SIZE};
use crate::SharedSecret;

use libcrux_ml_kem::mlkem1024::{
    decapsulate, encapsulate, generate_key_pair, MlKem1024Ciphertext, MlKem1024KeyPair,
    MlKem1024PublicKey,
};

use rand_core;
use rand_core::RngCore;
use sha3::digest::{ExtendableOutput, Update, XofReader};
use sha3::Shake256;
use x25519_dalek::{EphemeralSecret, PublicKey, StaticSecret};
use zeroize::{Zeroize, ZeroizeOnDrop};

const MLKEM1024_PK_SIZE: usize = 1568;
pub const MLKEM1024_CT_SIZE: usize = 1568;

pub const XWING1024_ENCAPSULATION_KEY_SIZE: usize = MLKEM1024_PK_SIZE + X25519_KEY_SIZE;
pub const XWING1024_DECAPSULATION_KEY_SIZE: usize = X25519_KEY_SIZE;
pub const XWING1024_CIPHERTEXT_SIZE: usize = MLKEM1024_CT_SIZE + X25519_KEY_SIZE;

#[derive(Clone, Debug, PartialEq)]
pub struct EncapsulationKey {
    pk_m: [u8; MLKEM1024_PK_SIZE],
    pk_x: PublicKey,
}

#[derive(Clone, ZeroizeOnDrop)]
pub struct DecapsulationKey {
    seed: [u8; MASTER_SEED_SIZE],
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Ciphertext {
    ct_m: [u8; MLKEM1024_CT_SIZE],
    ct_x: PublicKey,
}

impl EncapsulationKey {
    #[must_use]
    pub fn to_bytes(&self) -> [u8; XWING1024_ENCAPSULATION_KEY_SIZE] {
        let mut buffer = [0u8; XWING1024_ENCAPSULATION_KEY_SIZE];
        buffer[..MLKEM1024_PK_SIZE].copy_from_slice(&self.pk_m);
        buffer[MLKEM1024_PK_SIZE..].copy_from_slice(&self.pk_x.to_bytes());
        buffer
    }

    pub fn encapsulate(&self) -> (Ciphertext, SharedSecret) {
        let pk_m = MlKem1024PublicKey::from(*self.pk_m());
        let mut ml_rand = [0u8; 32];
        rand_core::OsRng.fill_bytes(&mut ml_rand);
        let (ct_m, mut ss_m) = encapsulate(&pk_m, ml_rand);

        let ct_m_bytes: [u8; MLKEM1024_CT_SIZE] = ct_m
            .as_ref()
            .try_into()
            .expect("ML-KEM ciphertext size mismatch");

        ml_rand.zeroize();

        let ephemeral = EphemeralSecret::random_from_rng(rand_core::OsRng);
        let ct_x = PublicKey::from(&ephemeral);
        let mut ss_x = ephemeral.diffie_hellman(self.pk_x()).to_bytes();

        let ct_x_bytes = ct_x.to_bytes();
        let pk_x_bytes = self.pk_x().to_bytes();
        let ss = combiner(&ss_m, &ss_x, &ct_x_bytes, &pk_x_bytes);

        ss_m.zeroize();
        ss_x.zeroize();

        (
            Ciphertext {
                ct_m: ct_m_bytes,
                ct_x,
            },
            ss,
        )
    }

    /// Public getter for pk_m
    pub fn pk_m(&self) -> &[u8; MLKEM1024_PK_SIZE] {
        &self.pk_m
    }

    /// Public getter for pk_x
    pub fn pk_x(&self) -> &PublicKey {
        &self.pk_x
    }

    /// Deterministic generation from 32-byte seed
    pub fn from_seed(seed: &[u8; MASTER_SEED_SIZE]) -> Self {
        let (kp, x_bytes) = expand_seed(seed);
        let pk_m_bytes: [u8; MLKEM1024_PK_SIZE] = kp
            .public_key()
            .as_ref()
            .try_into()
            .expect("ML-KEM public key size mismatch");

        let sk_x = StaticSecret::from(x_bytes);
        let pk_x = PublicKey::from(&sk_x);

        Self::from_components(pk_m_bytes, pk_x)
    }
}

impl From<&[u8; XWING1024_ENCAPSULATION_KEY_SIZE]> for EncapsulationKey {
    fn from(bytes: &[u8; XWING1024_ENCAPSULATION_KEY_SIZE]) -> Self {
        let mut pk_m = [0u8; MLKEM1024_PK_SIZE];
        pk_m.copy_from_slice(&bytes[..MLKEM1024_PK_SIZE]);
        let pk_x_bytes: [u8; 32] = bytes[MLKEM1024_PK_SIZE..].try_into().unwrap();
        let pk_x = PublicKey::from(pk_x_bytes);
        Self { pk_m, pk_x }
    }
}

impl EncapsulationKey {
    pub fn from_components(pk_m: [u8; MLKEM1024_PK_SIZE], pk_x: PublicKey) -> Self {
        Self { pk_m, pk_x }
    }
}

impl DecapsulationKey {
    pub fn generate<R: rand_core::RngCore + rand_core::CryptoRng>(rng: &mut R) -> Self {
        let mut seed = [0u8; MASTER_SEED_SIZE];
        rng.fill_bytes(&mut seed);
        Self { seed }
    }

    #[must_use]
    pub fn encapsulation_key(&self) -> EncapsulationKey {
        let (kp, x_bytes) = expand_seed(&self.seed);
        let pk_m_bytes: [u8; MLKEM1024_PK_SIZE] = kp
            .public_key()
            .as_ref()
            .try_into()
            .expect("ML-KEM public key size mismatch");

        let sk_x = StaticSecret::from(x_bytes);
        let pk_x = PublicKey::from(&sk_x);

        EncapsulationKey {
            pk_m: pk_m_bytes,
            pk_x,
        }
    }

    #[must_use]
    pub fn decapsulate(&self, ct: &Ciphertext) -> SharedSecret {
        let (kp, x_bytes) = expand_seed(&self.seed);

        let sk_m = kp.private_key();
        let ct_m = MlKem1024Ciphertext::from(*ct.ct_m());
        let mut ss_m = decapsulate(sk_m, &ct_m);

        let sk_x = StaticSecret::from(x_bytes);
        let mut ss_x = sk_x.diffie_hellman(ct.ct_x()).to_bytes();

        let pk_x = PublicKey::from(&sk_x);
        let ct_x_bytes = ct.ct_x().to_bytes();
        let pk_x_bytes = pk_x.to_bytes();

        let ss = combiner(&ss_m, &ss_x, &ct_x_bytes, &pk_x_bytes);

        ss_m.zeroize();
        ss_x.zeroize();

        ss
    }

    /// Deterministic generation from 32-byte seed
    pub fn from_seed(seed: &[u8; MASTER_SEED_SIZE]) -> Self {
        Self { seed: *seed }
    }
}

impl Ciphertext {
    #[must_use]
    pub fn to_bytes(&self) -> [u8; XWING1024_CIPHERTEXT_SIZE] {
        let mut buffer = [0u8; XWING1024_CIPHERTEXT_SIZE];
        buffer[..MLKEM1024_CT_SIZE].copy_from_slice(&self.ct_m);
        buffer[MLKEM1024_CT_SIZE..].copy_from_slice(&self.ct_x.to_bytes());
        buffer
    }
}

impl From<&[u8; XWING1024_CIPHERTEXT_SIZE]> for Ciphertext {
    fn from(bytes: &[u8; XWING1024_CIPHERTEXT_SIZE]) -> Self {
        let mut ct_m = [0u8; MLKEM1024_CT_SIZE];
        ct_m.copy_from_slice(&bytes[..MLKEM1024_CT_SIZE]);
        let ct_x_bytes: [u8; 32] = bytes[MLKEM1024_CT_SIZE..].try_into().unwrap();
        let ct_x = PublicKey::from(ct_x_bytes);
        Self { ct_m, ct_x }
    }
}

impl Ciphertext {
    pub fn from_components(ct_m: [u8; MLKEM1024_CT_SIZE], ct_x: PublicKey) -> Self {
        Self { ct_m, ct_x }
    }

    /// Public getter for ct_m
    pub fn ct_m(&self) -> &[u8; MLKEM1024_CT_SIZE] {
        &self.ct_m
    }

    /// Public getter for ct_x
    pub fn ct_x(&self) -> &x25519_dalek::PublicKey {
        &self.ct_x
    }
}

pub fn generate_keypair<R: rand_core::RngCore + rand_core::CryptoRng>(
    rng: &mut R,
) -> (DecapsulationKey, EncapsulationKey) {
    let sk = DecapsulationKey::generate(rng);
    let pk = sk.encapsulation_key();
    (sk, pk)
}

fn expand_seed(seed: &[u8; MASTER_SEED_SIZE]) -> (MlKem1024KeyPair, [u8; 32]) {
    let mut hasher = Shake256::default();
    hasher.update(seed);
    let mut reader = hasher.finalize_xof();

    // Draft-09: expand to 96 bytes using SHAKE256(sk, 96*8)
    let mut expanded = [0u8; 96];
    reader.read(&mut expanded);

    // Draft-09: ML-KEM-1024.KeyGen_internal(expanded[0:32], expanded[32:64])
    // libcrux expects concatenated d || z, so we provide the first 64 bytes
    let mut ml_seed = [0u8; 64];
    ml_seed.copy_from_slice(&expanded[..64]);
    let kp = generate_key_pair(ml_seed);
    ml_seed.zeroize();

    // Draft-09: sk_X = expanded[64:96]
    let mut x_bytes = [0u8; 32];
    x_bytes.copy_from_slice(&expanded[64..]);

    expanded.zeroize();

    (kp, x_bytes)
}



================================================================================
// SECTION 008: src/xwing768.rs
// Created:  2025-12-22 04:32:33.099
// Modified: 2025-12-23 18:36:20.578
================================================================================
// src/xwing_kem_768.rs

use crate::combiner;
use crate::consts::{MASTER_SEED_SIZE, X25519_KEY_SIZE};
use crate::SharedSecret;

use libcrux_ml_kem::mlkem768::{
    decapsulate, encapsulate, generate_key_pair, MlKem768Ciphertext, MlKem768KeyPair,
    MlKem768PublicKey,
};

use sha3::digest::{ExtendableOutput, Update, XofReader};
use sha3::Shake256;
use x25519_dalek::{EphemeralSecret, PublicKey, StaticSecret};
use zeroize::{Zeroize, ZeroizeOnDrop};

const MLKEM768_PK_SIZE: usize = 1184;
pub const MLKEM768_CT_SIZE: usize = 1088;

pub const XWING768_ENCAPSULATION_KEY_SIZE: usize = MLKEM768_PK_SIZE + X25519_KEY_SIZE;
pub const XWING768_DECAPSULATION_KEY_SIZE: usize = X25519_KEY_SIZE;
pub const XWING768_CIPHERTEXT_SIZE: usize = MLKEM768_CT_SIZE + X25519_KEY_SIZE;

#[derive(Clone, Debug, PartialEq)]
pub struct EncapsulationKey {
    pk_m: [u8; MLKEM768_PK_SIZE],
    pk_x: PublicKey,
}

#[derive(Clone, ZeroizeOnDrop)]
pub struct DecapsulationKey {
    seed: [u8; MASTER_SEED_SIZE],
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Ciphertext {
    ct_m: [u8; MLKEM768_CT_SIZE],
    ct_x: PublicKey,
}

impl EncapsulationKey {
    #[must_use]
    pub fn to_bytes(&self) -> [u8; XWING768_ENCAPSULATION_KEY_SIZE] {
        let mut buffer = [0u8; XWING768_ENCAPSULATION_KEY_SIZE];
        buffer[..MLKEM768_PK_SIZE].copy_from_slice(&self.pk_m);
        buffer[MLKEM768_PK_SIZE..].copy_from_slice(&self.pk_x.to_bytes());
        buffer
    }

    pub fn encapsulate<R: rand_core::RngCore + rand_core::CryptoRng>(
        &self,
        rng: &mut R,
    ) -> (Ciphertext, SharedSecret) {
        let pk_m = MlKem768PublicKey::from(self.pk_m);
        let mut ml_rand = [0u8; 32];
        rng.fill_bytes(&mut ml_rand);
        let (ct_m, mut ss_m) = encapsulate(&pk_m, ml_rand);

        let ct_m_bytes: [u8; MLKEM768_CT_SIZE] = ct_m
            .as_ref()
            .try_into()
            .expect("ML-KEM ciphertext size mismatch");

        ml_rand.zeroize();

        let ephemeral = EphemeralSecret::random_from_rng(rng);
        let ct_x = PublicKey::from(&ephemeral);
        let mut ss_x = ephemeral.diffie_hellman(&self.pk_x).to_bytes();

        let ct_x_bytes = ct_x.to_bytes();
        let pk_x_bytes = self.pk_x.to_bytes();
        let ss = combiner(&ss_m, &ss_x, &ct_x_bytes, &pk_x_bytes);

        ss_m.zeroize();
        ss_x.zeroize();

        (
            Ciphertext {
                ct_m: ct_m_bytes,
                ct_x,
            },
            ss,
        )
    }
}

impl From<&[u8; XWING768_ENCAPSULATION_KEY_SIZE]> for EncapsulationKey {
    fn from(bytes: &[u8; XWING768_ENCAPSULATION_KEY_SIZE]) -> Self {
        let mut pk_m = [0u8; MLKEM768_PK_SIZE];
        pk_m.copy_from_slice(&bytes[..MLKEM768_PK_SIZE]);
        let pk_x_bytes: [u8; 32] = bytes[MLKEM768_PK_SIZE..].try_into().unwrap();
        let pk_x = PublicKey::from(pk_x_bytes);
        Self { pk_m, pk_x }
    }
}

impl DecapsulationKey {
    pub fn generate<R: rand_core::RngCore + rand_core::CryptoRng>(rng: &mut R) -> Self {
        let mut seed = [0u8; MASTER_SEED_SIZE];
        rng.fill_bytes(&mut seed);
        Self { seed }
    }

    #[must_use]
    pub fn encapsulation_key(&self) -> EncapsulationKey {
        let (kp, x_bytes) = expand_seed(&self.seed);
        let pk_m_bytes: [u8; MLKEM768_PK_SIZE] = kp
            .public_key()
            .as_ref()
            .try_into()
            .expect("ML-KEM public key size mismatch");

        let sk_x = StaticSecret::from(x_bytes);
        let pk_x = PublicKey::from(&sk_x);

        EncapsulationKey {
            pk_m: pk_m_bytes,
            pk_x,
        }
    }

    #[must_use]
    pub fn decapsulate(&self, ct: &Ciphertext) -> SharedSecret {
        let (kp, x_bytes) = expand_seed(&self.seed);

        // kp.private_key() returns &MlKem768PrivateKey
        let sk_m = kp.private_key();
        let ct_m = MlKem768Ciphertext::from(ct.ct_m);
        // No extra & on sk_m – it's already a reference
        let mut ss_m = decapsulate(sk_m, &ct_m);

        let sk_x = StaticSecret::from(x_bytes);
        let mut ss_x = sk_x.diffie_hellman(&ct.ct_x).to_bytes();

        let pk_x = PublicKey::from(&sk_x);
        let ct_x_bytes = ct.ct_x.to_bytes();
        let pk_x_bytes = pk_x.to_bytes();

        let ss = combiner(&ss_m, &ss_x, &ct_x_bytes, &pk_x_bytes);

        ss_m.zeroize();
        ss_x.zeroize();

        ss
    }
}
impl Ciphertext {
    #[must_use]
    pub fn to_bytes(&self) -> [u8; XWING768_CIPHERTEXT_SIZE] {
        let mut buffer = [0u8; XWING768_CIPHERTEXT_SIZE];
        buffer[..MLKEM768_CT_SIZE].copy_from_slice(&self.ct_m);
        buffer[MLKEM768_CT_SIZE..].copy_from_slice(&self.ct_x.to_bytes());
        buffer
    }
}

impl From<&[u8; XWING768_CIPHERTEXT_SIZE]> for Ciphertext {
    fn from(bytes: &[u8; XWING768_CIPHERTEXT_SIZE]) -> Self {
        let mut ct_m = [0u8; MLKEM768_CT_SIZE];
        ct_m.copy_from_slice(&bytes[..MLKEM768_CT_SIZE]);
        let ct_x_bytes: [u8; 32] = bytes[MLKEM768_CT_SIZE..].try_into().unwrap();
        let ct_x = PublicKey::from(ct_x_bytes);
        Self { ct_m, ct_x }
    }
}

pub fn generate_keypair<R: rand_core::RngCore + rand_core::CryptoRng>(
    rng: &mut R,
) -> (DecapsulationKey, EncapsulationKey) {
    let sk = DecapsulationKey::generate(rng);
    let pk = sk.encapsulation_key();
    (sk, pk)
}

fn expand_seed(seed: &[u8; MASTER_SEED_SIZE]) -> (MlKem768KeyPair, [u8; 32]) {
    let mut hasher = Shake256::default();
    hasher.update(seed);
    let mut reader = hasher.finalize_xof();

    // Draft-09: expand to 96 bytes using SHAKE256(sk, 96*8)
    let mut expanded = [0u8; 96];
    reader.read(&mut expanded);

    // Draft-09: ML-KEM-768.KeyGen_internal(expanded[0:32], expanded[32:64])
    // libcrux expects concatenated d || z, so we provide the first 64 bytes
    let mut ml_seed = [0u8; 64];
    ml_seed.copy_from_slice(&expanded[..64]);
    let kp = generate_key_pair(ml_seed);
    ml_seed.zeroize();

    // Draft-09: sk_X = expanded[64:96]
    let mut x_bytes = [0u8; 32];
    x_bytes.copy_from_slice(&expanded[64..]);

    expanded.zeroize();

    (kp, x_bytes)
}
